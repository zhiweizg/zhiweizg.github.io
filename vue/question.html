<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue | 是温柔的风</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.e4d8b86b.css" as="style"><link rel="preload" href="/assets/js/app.2bec0f6e.js" as="script"><link rel="preload" href="/assets/js/2.0e47e04c.js" as="script"><link rel="preload" href="/assets/js/13.ffdc8d84.js" as="script"><link rel="prefetch" href="/assets/js/10.9617147d.js"><link rel="prefetch" href="/assets/js/11.6331f824.js"><link rel="prefetch" href="/assets/js/12.1f72fbf9.js"><link rel="prefetch" href="/assets/js/3.e7d97d8a.js"><link rel="prefetch" href="/assets/js/4.23170bb5.js"><link rel="prefetch" href="/assets/js/5.b785003b.js"><link rel="prefetch" href="/assets/js/6.e652b7d6.js"><link rel="prefetch" href="/assets/js/7.53d7b1d5.js"><link rel="prefetch" href="/assets/js/8.238f29d6.js"><link rel="prefetch" href="/assets/js/9.3cb351f6.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e4d8b86b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">是温柔的风</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">Learn</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">Learn</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vue/question.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  vue实践
</a></li><li class="dropdown-item"><!----> <a href="/react/question.html" class="nav-link">
  react实践
</a></li></ul></div></div><div class="nav-item"><a href="/play/xixi.html" class="nav-link">
  xixi
</a></div><div class="nav-item"><a href="https://github.com/zhiweizg" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">Learn</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">Learn</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vue/question.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  vue实践
</a></li><li class="dropdown-item"><!----> <a href="/react/question.html" class="nav-link">
  react实践
</a></li></ul></div></div><div class="nav-item"><a href="/play/xixi.html" class="nav-link">
  xixi
</a></div><div class="nav-item"><a href="https://github.com/zhiweizg" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>vue问题</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue/question.html" aria-current="page" class="active sidebar-link">vue</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue/question.html#vuex-怎么合理规范管理数据-及-mutations-和-actions-区别" class="sidebar-link">vuex 怎么合理规范管理数据,及 mutations 和 actions 区别</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue/question.html#mutations-和-actions-的区别" class="sidebar-link">mutations 和 actions 的区别</a></li></ul></li><li class="sidebar-sub-header"><a href="/vue/question.html#vuex-模块化-module-管理-使用的时候有注意事项" class="sidebar-link">vuex 模块化 module 管理,使用的时候有注意事项</a></li><li class="sidebar-sub-header"><a href="/vue/question.html#封装-vue-组件的步骤" class="sidebar-link">封装 Vue 组件的步骤</a></li><li class="sidebar-sub-header"><a href="/vue/question.html#vue-中的-data-是以函数的形式还是对象的形式表示" class="sidebar-link">Vue 中的 data 是以函数的形式还是对象的形式表示</a></li><li class="sidebar-sub-header"><a href="/vue/question.html#使用-proxy-代理跨域" class="sidebar-link">使用 Proxy 代理跨域</a></li><li class="sidebar-sub-header"><a href="/vue/question.html#vue-中的-watch-如何深度监听某个对象" class="sidebar-link">Vue 中的 watch 如何深度监听某个对象</a></li><li class="sidebar-sub-header"><a href="/vue/question.html#vue-keep-alive-使用" class="sidebar-link">Vue keep-alive 使用</a></li><li class="sidebar-sub-header"><a href="/vue/question.html#vue-的双向数据绑定原理是什么" class="sidebar-link">vue 的双向数据绑定原理是什么</a></li><li class="sidebar-sub-header"><a href="/vue/question.html#页面刷新了之后-vuex-中的数据消失怎么解决" class="sidebar-link">页面刷新了之后 vuex 中的数据消失怎么解决</a></li><li class="sidebar-sub-header"><a href="/vue/question.html#vue-做服务端渲染" class="sidebar-link">vue 做服务端渲染</a></li><li class="sidebar-sub-header"><a href="/vue/question.html#vue-router-传参" class="sidebar-link">vue-router 传参</a></li><li class="sidebar-sub-header"><a href="/vue/question.html#前端鉴权一般思路" class="sidebar-link">前端鉴权一般思路</a></li><li class="sidebar-sub-header"><a href="/vue/question.html#vue-数据流-和-react-数据流" class="sidebar-link">vue 数据流 和 react 数据流</a></li><li class="sidebar-sub-header"><a href="/vue/question.html#如何在组件中监听-vuex-的数据变化" class="sidebar-link">如何在组件中监听 Vuex 的数据变化</a></li><li class="sidebar-sub-header"><a href="/vue/question.html#vue-单页面和多页面的使用" class="sidebar-link">Vue 单页面和多页面的使用</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue-部分相关的面试题"><a href="#vue-部分相关的面试题" class="header-anchor">#</a> Vue 部分相关的面试题</h1> <p>vue 传值‘</p> <p>1 父 子 传值 使用 props 接受</p> <p>2 子 父 传值 父亲写事件函数 子 $emit 触发 传值</p> <p>3 兄弟传值 $bus 中转站</p> <p>4 如果组件之间 关系很远 是很多组件都要用的值 <strong>vuex</strong></p> <p><strong>vuex</strong> <strong>就是一个全局状态数据管理</strong> 简单来说 他的数据类似全局变量 哪个组件都可以使用</p> <p><strong>在项目中使用 vuex</strong></p> <ol><li><p>下载 vuex 包 并导入 use 一下</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>import Vuex from 'vuex'
Vue.use(Vuex)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>需要 new 一下 写上全局数据</p></li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>// store
new Vuex.Store({
 state: {
    count:1 //这个count 就是全局的数据
 },
 mutations: {
 },
 actions: {
 }
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><ol start="3"><li><p>需要挂载到 new vue 上</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>new Vue({
router,
store,
render: h =&gt; h(App)
}).$mount('#app')
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li></ol> <p><strong>这个步骤是写死的 你可以记一下 下载使用脚手架直接就可以选 vuex</strong></p> <p><strong>他的使用逻辑是什么？</strong></p> <p>在 store 里面的 state 写的数据 是全局数据 所有组件都可以使用</p> <p><strong>使用逻辑</strong></p> <p><strong>操作全局 vuex 的 state 数据</strong></p> <p>正常情况 必须 dispatch (action)---&gt;action 去 commit 触发 mutation--》mutation 里面才能修改 state 全局数据</p> <p>​ action---&gt;mutation---&gt;修改 state</p> <p>其他情况 你也可以跳过 action 去 直接 commit mutation--》修改 state 全局数据</p> <h2 id="vuex-怎么合理规范管理数据-及-mutations-和-actions-区别"><a href="#vuex-怎么合理规范管理数据-及-mutations-和-actions-区别" class="header-anchor">#</a> vuex 怎么合理规范管理数据,及 mutations 和 actions 区别</h2> <blockquote><p>解析: 此题考查 vuex 中数据的管理和数据结构的设计,还有 mutations 和 actions 的区别</p></blockquote> <blockquote><p><strong><code>解答</code></strong> : 首先要明确一个特别重要的原则, 就是 不是所有的数据都要放在 vuex 中, 因为 vuex 有一句名言:假如你并不知道为什么要使用 vuex,那就不要使用它 !</p> <p>那么什么样式的数据需要放在 vuex 中呢 ? 首先这个数据肯定要被多个组件频繁用到, 如果只是被一个组件 用到, 那完全没有任何必要为了使用 vuex 和使用 vuex</p></blockquote> <p>举例: 一个网站用户的昵称,账号,资料,像这种系统级别的信息 随时可能在业务中展示,使用, 如果在组件中存储, 那么要获取 N 次, 所以**<code>系统级别的数据</code>**是需要放置在 vuex 中的, 那么系统级别数据 也不能所以的放置,为了让数据看着更有层级结构感,可以按照像下面这样设计,</p> <div class="language-json line-numbers-mode"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token comment">// 系统消息</span>
  <span class="token property">&quot;system&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">&quot;user&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token property">&quot;setting&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><blockquote><p>上面这种结构,一看 便知道我们应该哪里获取系统数据即 设置数据</p></blockquote> <p>如果有些业务数据,也需要共享,最好按照模块的具体业务含义分类 , 比如下面</p> <div class="language-json line-numbers-mode"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token comment">// 系统消息</span>
  <span class="token property">&quot;system&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">&quot;user&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token property">&quot;setting&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token property">&quot;product&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">&quot;productList&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 商品信息列表</span>
    <span class="token property">&quot;productOrders&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">// 商品订单啊列表</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><blockquote><p>如上图代码所示,我们很清晰的能够分清楚 每个模块的数据,这样不会导致数据管理的混乱</p></blockquote> <h3 id="mutations-和-actions-的区别"><a href="#mutations-和-actions-的区别" class="header-anchor">#</a> mutations 和 actions 的区别</h3> <blockquote><p>不同于 redux 只有一个 action, vuex 单独拎出了一个 mutations, 它认为 更新数据必须是同步的, 也就是只要调用了 提交数据方法, 在 mutation 里面才可以修改数据</p> <p>那么如果我们想做 异步请求,怎么做? 这里 vuex 提供了专门做异步请求的模块,action, 当然 action 中也可以做同步操作, 只不过 分工更加明确, 所有的数据操作 不论是同步还是异步 都可以在 action 中完成,</p> <p>mutation 只负责接收状态, 同步完成 <strong><code>数据快照</code></strong></p> <p>所以可以认为</p> <p>state =&gt; 负责存储状态</p> <p>mutations =&gt; 负责同步更新状态</p> <p><strong>actions =&gt; 负责获取 处理数据（如果有异步操作必须在 action 处理 再到 mutation）</strong>, 提交到 mutation 进行状态更新</p></blockquote> <h2 id="vuex-模块化-module-管理-使用的时候有注意事项"><a href="#vuex-模块化-module-管理-使用的时候有注意事项" class="header-anchor">#</a> vuex 模块化 module 管理,使用的时候有注意事项</h2> <p>pro111</p> <blockquote><p>分析: 此题考查 当 vuex 维护的数据越来越复杂的时候, 模块化的解决方案</p> <p><strong><code>解析</code></strong>:使用单一的状态树，应用的所有状态都会**<code>集中在一个比较大的对象</code><strong>上面，随着项目需求的不断增加，状态树也会变得越来越臃肿，增加了状态树维护的复杂度,而且代码变得沉长；因此我们需要</strong><code>modules(模块化)</code><strong>来为我们的状态树</strong><code>分隔</code>**成不同的模块，每个模块拥有自己的 state，getters，mutations，actions；而且允许每个 module 里面嵌套子 module；如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code> store
    ├── index.js          # 我们组装模块并导出 store 的地方
    ├── actions.js        # 根级别的 action
    ├── mutations.js      # 根级别的 mutation
    ├── state.js          # 根级别的 state
    └── modules
        ├── module1.js   # 模块1的state树
        └── module2.js   # 模块2的state树
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></blockquote> <p>上面的设计中, 每个 vuex 子模块都可以定义 state/mutations/actions</p> <blockquote><p>需要注意的是 我们原来使用**<code>vuex辅助函数</code>** mapMutations/mapActions 引入的是 全局的的 mutations 和 actions , 并且我们 vuex 子模块 也就是 module1,module2 ... 这些模块的 aciton /mutation 也注册了全局,</p> <p>也就是如果 module1 中定义了 loginMutation, module2 中也定义了 loginMutation, 此时, mutation 就冲突了</p> <p>如果重名,就报错了.....</p> <p>如果不想冲突, 各个模块管理自己的 action 和 mutation ,需要 给我们的子模块一个 属性 <strong><code>namespaced: true</code></strong></p></blockquote> <p>那么 组件中怎么使用子模块的 action 和 mutations</p> <p>你写一遍 步骤基本是死的 熟悉就好了</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 你可以将模块的空间名称字符串作为第一个参数传递给上述函数，这样所有绑定都会自动将该模块作为上下文</span>
 <span class="token literal-property property">methods</span><span class="token operator">:</span><span class="token punctuation">{</span>
     <span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token string">'m1'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'loginMutation'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
     <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'add'</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">)</span>
      <span class="token comment">//  this.$store.commit(&quot;m1/loginMutation&quot;)</span>
      <span class="token comment">// 或者下面的  先mapMutations 相当于帮你写了commit</span>
      <span class="token comment">// this.loginMutation()</span>
     <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

     <span class="token comment">// 这句话的意思是 直接 解构出 全局 m1模块下的 loginMutation</span>
    <span class="token comment">// 把loginMutation 放到this上 并且帮你写好了 commit</span>
    <span class="token comment">// 相当于帮你简化了代码</span>
     <span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token string">'m1'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'loginMutation'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
       <span class="token comment">//不是modules的直接写  ...mapMutations( ['loginMutaton])</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><blockquote><p>此题具体考查 Vuex 虽然是一个公共状态, 但是公共状态还可以切分成若干个子状态模块, 也就是 moduels,</p> <p>解决当我们的状态树过于庞大和复杂时的一种解决方案. 但是笔者认为, 一旦用了 vuex, 几乎 就认定该项目是较为复杂的</p></blockquote> <p><a href="https://vuex.vuejs.org/zh/guide/modules.html" target="_blank" rel="noopener noreferrer">参考文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="封装-vue-组件的步骤"><a href="#封装-vue-组件的步骤" class="header-anchor">#</a> 封装 Vue 组件的步骤</h2> <p>pro111</p> <p>组件是什么？组件是一段功能代码 ---大白话 就是一段 html +js +css 你可以重复使用</p> <p>封装轮播图 - 1 新建 vue 组件 2 Vue.component 注册组件 3 在其他组件使用 标签名</p> <p>参数： 可以传入数据 使用 props 接受 比如 数组 定时器时间等</p> <blockquote><p>分析: 本题考查 对于 Vue 组件化开发的熟练程度</p> <p><strong><code>解析</code></strong>: 首先明确 组件是本质是什么?</p> <p>组件就是一个单位的 HTML 结构 + 数据逻辑 + 样式的 操作单元</p> <p>Vue 的组件 继承自 Vue 对象, Vue 对象中的所有的属性和方法,组件可自动继承.</p> <p>组件的要素 template =&gt; 作为页面的模板结构</p> <p>script =&gt; 作为数据及逻辑的部分</p> <p>style =&gt; 作为该组件部分的样式部分</p></blockquote> <p>要封装一个组件,首先要明确该组件要做的具体业务和需求, 什么样的体验特征, 完成什么样的交互, 处理什么样的数据</p> <blockquote><p>明确上述要求之后, 着手模板的结构设计及搭建,也就是 常说的 html 结构部分, 先完成 静态的 html 结构</p> <p>结构完成, 着手数据结构的设计及开发, 数据结构一般存储于组件的 data 属性 或者 vuex 状态共享的数据结构</p> <p>数据设计完成/ 结构完成 接下来 完成数据和模块的结合 , 利用 vuejs 中指令和 插值表达式的特性 将静态结构 <strong><code>动态化</code></strong></p> <p>展现的部分完成, 接下来完成**<code>交互部分</code>**,即利用 组件的生命周期的钩子函数 和 事件驱动 来完成 逻辑及数据的处理与操作</p></blockquote> <p>最后组件完成,进行测试及使用</p> <p>常用的组件属性 =&gt; data/ methods/filters/ components/watch/created/mounted/beforeDestroy/computed/props</p> <p>常用组件指令: v-if/v-on/v-bind/v-model/v-text/v-once</p> <h2 id="vue-中的-data-是以函数的形式还是对象的形式表示"><a href="#vue-中的-data-是以函数的形式还是对象的形式表示" class="header-anchor">#</a> Vue 中的 data 是以函数的形式还是对象的形式表示</h2> <blockquote><p>分析: 此题考查 data 的存在形式</p></blockquote> <blockquote><p><strong><code>解析</code></strong>: 我们在初步学习 Vue 实例化的时候写的代码时这个样子</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">el</span><span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'hello world'</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>上面代码中的 data 是一个对象, 但是我们在开发组件的时候要求 data 必须是一个带返回值的函数</p></blockquote> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'张三'</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><blockquote><p>为什么组件要求必须是带返回值的函数? 因为 我们的组件在实例化的时候, 会直接将 data 数据作用在视图上,</p> <p>对组件实例化, 会导致我们组件的 data 数据进行共享, 好比 现在有两辆新车, 你一踩油门, 不光你的车往前车,另辆车也和你一样往前冲! 这显然不符合我们的程序设计要求, 我们希望组件内部的数据是相互独立的,且互不响应,所以 采用 <strong><code>return {}</code></strong> 每个组件实例都返回新对象实例的形式,保证每个组件实例的唯一性</p></blockquote> <h2 id="使用-proxy-代理跨域"><a href="#使用-proxy-代理跨域" class="header-anchor">#</a> 使用 Proxy 代理跨域</h2> <p>pro111</p> <p>什么是跨域？</p> <p>域名 协议 ip 地址 端口 任何一个不一样 就跨域</p> <p>解决跨域？</p> <p>1 jsonp ---使用 script 的 src 发送 只能 get 请求</p> <p>2 cors 后台设置允许跨域 <strong>需要后台设置</strong> 允许跨域</p> <p>​ 所有后台语言 都可以设置</p> <p>3 服务器代理</p> <p><strong>重点 现在 前端 vue 框架 是可以自己设置 服务器代理的</strong> proxy</p> <p>​ <strong>配置就行</strong></p> <p><strong>vue 在 vue.config.js 可以配置重写 webpack</strong></p> <blockquote><p>分析: 本题考查如何解决跨域问题</p> <p>解析: 解决跨域问题的方式有几种,</p> <p><strong>1 一种是服务端设置</strong> , 但这种方式依赖服务端的设置,在前后分离的场景下 ,不太方便</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Access-Control-Allow-Origin：*
Access-Control-Allow-Methods：&quot;POST, GET, OPTIONS, DELETE&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>2 还有一种 jsonp 形式</strong>, 可以利用 script 标签 的特性解决同源策略带来的跨域问题,但这是这种方案对于请求的类型有限制,只能 get</p> <p><strong>3 还有一种就可以在开发环境(本地调试)期间,进行代理</strong>, 说白了 就是通过 在本地通过 nodejs 启动一个微型服务,</p> <p>然后我们先请求我们的微型服务, 微型服务是服务端, 服务端**<code>代我们</code><strong>去请求我们想要的跨域地址, 因为服务端是不受</strong><code>同源策略</code>**的限制的, 具体到开发中,打包工具 webpack 集成了代理的功能,可以采用配置 webpack 的方式进行解决, 但是这种仅限于 本地开发期间, <strong>等项目上线时,还是需要另择代理 nginx</strong></p></blockquote> <p>以下为 webpack 配置代理的配置</p> <div class="language-json line-numbers-mode"><pre class="language-json"><code>
<span class="token comment">// vue.config.js</span>
module.exports = <span class="token punctuation">{</span>
  <span class="token comment">// 修改的配置</span>
  devServer<span class="token operator">:</span> <span class="token punctuation">{</span>
      proxy<span class="token operator">:</span> <span class="token punctuation">{</span>
          '/api'<span class="token operator">:</span> <span class="token punctuation">{</span>
              target<span class="token operator">:</span> 'http<span class="token operator">:</span><span class="token comment">//122.51.238.153',</span>
              changeOrigin<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
              pathRewrite<span class="token operator">:</span> <span class="token punctuation">{</span>
                '^/api'<span class="token operator">:</span> ''
              <span class="token punctuation">}</span>
          <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p><strong><code>target</code></strong>：接口域名；</p> <p><strong><code>changeOrigin</code></strong>： 如果设置为<code>true</code>,那么本地会虚拟一个服务端接收你的请求并代你发送该请求；</p> <p><strong><code>pathRewrite</code></strong>：如果接口中是没有 api 的，那就直接置空（如上）如果接口中有 api，就需要写成{‘^/api’:‘’}</p> <p><strong>上线了如果还有跨域 可以让后台设置 允许跨域</strong></p> <h2 id="vue-中的-watch-如何深度监听某个对象"><a href="#vue-中的-watch-如何深度监听某个对象" class="header-anchor">#</a> Vue 中的 watch 如何深度监听某个对象</h2> <blockquote><p>分析: 此题考查 Vue 的选项 watch 的应用方式</p> <p>解析: watch 最基本的用法是</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'张三'</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">watch</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">name</span><span class="token punctuation">(</span><span class="token parameter">newValue<span class="token punctuation">,</span> oldValue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>上面代码中: 有个原则监听谁,写谁的名字,然后是对应的执行函数, 第一个参数为最新的改变值,第二个值为上一次改变的值, 注意: 除了监听 data,也可以监听**<code>计算属性</code>** 或者一个 函数的计算结果</p> <p>那怎么深度监听对象 ,两种方式</p> <ol><li>字符串嵌套方式</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token punctuation">{</span>
          <span class="token literal-property property">c</span><span class="token operator">:</span> <span class="token string">'张三'</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">watch</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string-property property">'a.b.c'</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">newValue<span class="token punctuation">,</span> oldValue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><ol start="2"><li><p>启用深度监听方式</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    <span class="token function">data</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span>
           <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token punctuation">{</span>
               <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token punctuation">{</span>
                   <span class="token literal-property property">c</span> <span class="token operator">:</span><span class="token string">'张三'</span>
               <span class="token punctuation">}</span>
           <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token literal-property property">watch</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token literal-property property">deep</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token comment">// deep 为true  意味着开启了深度监听 a对象里面任何数据变化都会触发handler函数,</span>
            <span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
               <span class="token comment">// handler是一个固定写法</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div></li></ol></blockquote> <h2 id="vue-keep-alive-使用"><a href="#vue-keep-alive-使用" class="header-anchor">#</a> Vue keep-alive 使用</h2> <p>pro111</p> <blockquote><p>分析: 此题考查 Vue 中组件缓存的使用</p> <p>解析: keep-alive 是 Vue 提供的一个全局组件, Vue 的组件是有销毁机制的,比如条件渲染, 路由跳转时 组件都会经历**<code>销毁</code>**, 再次回到页面时,又会回到 <strong><code>重生</code></strong>, 这一过程保证了生命周期钩子函数各个过程都会在这一生命周期中执行.</p> <p>但是,我们辛辛苦苦获取的数据 滑动的页面 会因为组件的销毁 重生 而 <strong><code>归零</code></strong>,这影响了交互的体验, 所以 keep-alvie 出现了, 可以帮助我们缓存想要缓存的组件实例, 只用用 keep-alive **<code>包裹</code>**你想要缓存的组件实例, 这个时候, 组件创建之后,就不会再进行 销毁, 组件数据和状态得以保存</p> <p>但是,没有了销毁,也就失去了重生的环节, 我们失去了 原有的钩子函数, 所以 keep-alive 包裹的组件 都获取了另外<strong>两个事件 --如果缓存组件需要重新获取数据</strong></p> <p>唤醒 activated 重新唤醒休眠组件实例时 执行</p> <p>休眠 deactivated 组件实例进入休眠状态时执行</p></blockquote> <p>但是我们不能缓存所有的组件实例, 如果是针对 组件容器 router-view 这个组件进行的缓存, 一般的策略是在路由的元信息 meta 对象中设置是否缓存的标记, 然后根据标记决定是否进行缓存</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>  <span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">&quot;app&quot;</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>keep<span class="token operator">-</span>alive<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 里面是当需要缓存时 <span class="token operator">--</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>router<span class="token operator">-</span>view  v<span class="token operator">-</span><span class="token keyword">if</span><span class="token operator">=</span><span class="token string">&quot;$route.meta.isAlive&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>keep<span class="token operator">-</span>alive<span class="token operator">&gt;</span>
     <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 外面是不需要缓存时 <span class="token operator">--</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>router<span class="token operator">-</span>view  v<span class="token operator">-</span><span class="token keyword">if</span><span class="token operator">=</span><span class="token string">&quot;!$route.meta.isAlive&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>还有需要注意的问题是: 被缓存的组件中如果还有子组件, 那么子组件也会一并拥有 激活和唤醒事件,并且这些事件会在同时执行</p> <h2 id="vue-的双向数据绑定原理是什么"><a href="#vue-的双向数据绑定原理是什么" class="header-anchor">#</a> vue 的双向数据绑定原理是什么</h2> <p>pro111</p> <blockquote><p>分析 :此题考查 Vue 的 MVVM 原理</p> <p><strong><code>解答</code></strong>: Vue 的双向绑定原理其实就是 MVVM 的实现原理, Vuejs 官网已经说明, 实际就是通过 Object.defineProperty 方法 完成了对于 Vue 实例中数据的 <strong><code>劫持</code></strong>, 通过对于 data 中数据 set 的监听,</p> <p>然后通过**<code>观察者模式</code>**, 通知 对应的绑定节点 进行节点数据更新, 完成数据驱动视图的更新</p> <p>同理, 通过对于节点的表单值改变事件的监听, 执行对于数据的修改</p></blockquote> <p>简单概述 : 通过 Object.defineProperty 完成对于数据的劫持, 通过观察者模式, 完成对于节点的数据更新</p> <h2 id="页面刷新了之后-vuex-中的数据消失怎么解决"><a href="#页面刷新了之后-vuex-中的数据消失怎么解决" class="header-anchor">#</a> 页面刷新了之后 vuex 中的数据消失怎么解决</h2> <blockquote><p>分析:此题考查 如果将 vuex 数据进行本地持久化</p> <p><strong><code>解析</code></strong>: vuex 数据位于内存, 页面的刷新重置会导致数据的**<code>归零</code>**,也就是所谓的消失, 本地持久化可以解决这个问题.本地持久化用到的技术也就是 本次存储 sesstionStorage 或者 localStorage ,</p> <p>如果需要保持的更长久 ,浏览器关掉 再打开依然存有数据,需要使用后者</p> <p>实施方案: state 的持久化 也就是分别需要在 state 数据初始化 /更新 的时候 进行读取和设置本地存储操作</p> <p>代码如下</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">state</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">user</span><span class="token operator">:</span> localStorge<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">'user'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 初始化时读取 本地存储</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">mutations</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">updateUser</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> payload</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      state<span class="token punctuation">.</span>user <span class="token operator">=</span> payload<span class="token punctuation">.</span>user
      localStoregae<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">'user'</span><span class="token punctuation">,</span> payload<span class="token punctuation">.</span>user<span class="token punctuation">)</span> <span class="token comment">// 数据更新时 设置本地存储</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div></blockquote> <h2 id="vue-做服务端渲染"><a href="#vue-做服务端渲染" class="header-anchor">#</a> vue 做服务端渲染</h2> <p>pronuxt</p> <p><a href="https://zh.nuxtjs.org/guide/installation/" target="_blank" rel="noopener noreferrer">nuxt 官网文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <blockquote><p>分析: 为什么要做服务端渲染, 首先要明白 服务端渲染解决什么问题</p> <p><strong><code>解析</code></strong>: vuejs 官网说的很明白, 要做服务端渲染首先必须是有对应的需求,即对 实时到达时间(页面访问时间)的绝对需求. 如果只是简单的一个管理系统, 区区几百毫秒的优化 显得十分小题大做.</p> <p>服务端渲染这里 有一个成熟优秀的框架 nuxt.js , 正如 next.js 对于 react,nuxt 是 vue 服务端渲染的优秀解决方案</p></blockquote> <blockquote><p>nuxt 的出现可以让渲染内容完全服务端化,解决 seo 不够友好, 首屏渲染速度不够迅速的问题,</p> <p>但是这里需要注意: 并不是所有页面都需要服务端渲染, 因为服务端渲染比重多大 对于服务器的访问处理能力 要求也会急剧增大</p></blockquote> <div class="language- line-numbers-mode"><pre class="language-text"><code>步骤
  1 脚手架 npx create-nuxt-app &lt;项目名&gt;
  2 yarn dev 启动开发

  上线
  yarn build
  yarn start
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h5 id="为什么使用-nuxt-js"><a href="#为什么使用-nuxt-js" class="header-anchor">#</a> 为什么使用 nuxt.js?</h5> <p>vue 单页面应用渲染是从服务器获取所需 js，在客户端将其解析生成 html 挂载于
id 为 app 的 DOM 元素上，这样会存在两大问题。</p> <ol><li>由于资源请求量大，造成网站首屏加载缓慢，不利于用户体验。</li> <li>由于页面内容通过 js 插入，对于内容性网站来说，搜索引擎无法抓取网站内容，不利于 SEO。
Nuxt.js 是一个基于 Vue.js 的通用应用框架，预设了利用 Vue.js 开发服务端渲染的应用所需要的各种配置。可以将 html 在服务端渲染，合成完整的 html 文件再输出到浏览器。</li></ol> <p><strong>除此之外，nuxt 与 vue 还有一些其他方面的区别。</strong></p> <ol><li><p><strong>路由</strong>
nuxt 按照 pages 文件夹的目录结构自动生成路由
vue 需在 src/router/index.js 手动配置路由</p></li> <li><p><strong>入口页面</strong>
nuxt 页面入口为 layouts/default.vue
vue 页面入口为 src/App.vue</p></li> <li><p><strong>webpack 配置</strong>
nuxt 内置 webpack，允许根据服务端需求，在 nuxt.config.js 中的 build 属性自定义构建 webpack 的配置，覆盖默认配置
vue 关于 webpack 的配置存放在 build 文件夹下</p></li> <li><p><strong>asyncData 里面发送 ajax 这个东西跟生命周期这些都是平级的</strong></p></li></ol> <p>要理解 asyncData 方法执行时，其实是在服务端完成的，这个数据是在服务端渲染好了的</p> <p>​</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>unxtjs的ajax，你先别往你那个异步上去思考，其实这里面所有的ajax最后都会形成页面。你别想着，我一点按钮，调用一个方法，然后再ajax去加载数据。因为我们最后全部都会生成静态，所以任何的获取数据的操作，最后都会变成页面的跳转。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>所以，官方给了一套写法，你必须按照这个去写，
并且这里的 ajax 会再页面渲染之前就执行。这个东西跟生命周期这些都是平级的。</p> <p>1 cnpm install @nuxtjs/axios --save
2 .plugins 目录新建 axios.js</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>import * as axios from 'axios'

let options ={}

//需要全路径才能工作

if(process.server){

　　options.baseURL=http://${process.env.HOST || 'localhost'}:${process.env.PORT || 3000}/api

}

export default axios.create(options)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>3.Nuxt.config.js 增加 axios 配置</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>modules:[

　　'@nuxtjs/axios'

],

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>4 使用 asyncData 里面发送 ajax 这个东西跟生命周期这些都是平级的 在页面渲染之前</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export default {

  async asyncData({app}){

　　        let res =await app.$axios({

              　　headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
              　　method: 'get',
              　　url: `http://test.yms.cn/testjson.asp`,
              　　data: ''

        　　})
        // app.$axios
        　　console.log('res',res.data)
        　　return{
        　      　testData:res.data.title
        　　}
    },
    created(){
      console.log('nuxt reg组件')

    }

}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>下图为关于 nuxt 的简单概述</p> <h2 id="vue-router-传参"><a href="#vue-router-传参" class="header-anchor">#</a> vue-router 传参</h2> <blockquote><p>分析:考查 vue-router 的传值方式</p> <p><strong><code>解析</code></strong> vue-router 传值 可以通过 地址传值</p> <p>最简单的就是 url 传值, url 传值又两种, params 和 query 参数传值</p> <p>params 传值 是指的动态路由传值</p> <div class="language-vue line-numbers-mode"><pre class="language-vue"><code>{ path: '/user/:id' } // 定义一个路由参数
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/user/123<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">&gt;</span></span>
// 传值 this.$route.params.id // 取值
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>query 传值,指通过?后面的拼接参数传值</p> <div class="language-vue line-numbers-mode"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/user?id=123<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">&gt;</span></span>
// 传值 this.$route.query.id // 取值
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></blockquote> <h2 id="前端鉴权一般思路"><a href="#前端鉴权一般思路" class="header-anchor">#</a> 前端鉴权一般思路</h2> <blockquote><p>分析: 考查前后分离的鉴权思路</p></blockquote> <p><strong><code>解析</code></strong>: 首先要明白 为什么要在前端鉴权? 因为传统项目都是在后端鉴权, 然后通过进行拦截 跳转 对应操作</p> <p>因为 我们做的并不是传统的项目,而是前后分离项目,也就是前端项目和后端服务进行了**<code>剥离</code>**, 后端没有办法用 session 来存储你任意一个前端项目域名下的身份信息, 所以 jwt 鉴权模式应运而生.</p> <p>​ 也就是后端不再提供会话的身份存储,而是通过一个鉴权接口将用户的身份,登录时间,请求端口,协议头..等等信息 组装成一个加密的串 返给前端请求, 前端拿到了这个串,就可以认为自己登录成功</p> <p>那么这个**<code>加密串</code><strong>就成了 前端用户是否登录的成功标志, 这就是我们的 token , 那么在接下来的接口请求中,我们几乎都要携带这个加密串,因为它是</strong><code>唯一</code><strong>能</strong><code>证明我们身份</code>**的信息.</p> <p>为了方便,我们会一般在请求工具 axios(举例)的拦截器中**<code>统一注入token</code>**, 减少代码的重复</p> <p>token 同时具有时效性,我们也需要在此时对 token 过期进行处理,一旦出现过期的请求码, 就需要进行 换取新 token 或者重新登录的解决方案</p> <p>除此之外,我们还需要依据**<code>有无加密串</code>** 在前端对于某些页面的访问进行限制, 这个会用到我们的 Vue-Router 中的导航守卫.</p> <p><strong>vue 单页项目涉及到多角色用户权限问题，不同的角色用户拥有不同的功能权限， 不同的功能权限对应的不同的页面</strong></p> <p>一开始 有一些 默认的路由</p> <p>登录后 比如你是总经理 后台会返回给前端 总经理能看见的 路由页面地址 数组</p> <p>前端在 router.beforeEach 路由导航守卫里面 拿到返回的地址 使用 <strong>router.addRouter</strong> 动态加上 这个项目路由就好了</p> <p>routes= 后台返回的 符合条件的 路由数据 类似我们自己写的那个 path 等等
this.$router.addRoutes(routes)</p> <div class="language- extra-class"><pre><code>   例子

 router.beforeEach((to, from, next) =&gt; {

　　　　//判断user信息是否已经获取
        if (token) {
　　　　　　　　//根据用户的角色类型来生成对应的新路由
            const newRouter = [{path:&quot;/xxx&quot; ...} ..]
            //将新路由添加到路由中
　　　　　　　router.addRoutes(newRouter)
　　　　　　　　//为了正确渲染导航,将对应的新的路由添加到vuex中
                渲染对应的侧边栏
    }
})
</code></pre></div><h2 id="vue-数据流-和-react-数据流"><a href="#vue-数据流-和-react-数据流" class="header-anchor">#</a> vue 数据流 和 react 数据流</h2> <p>在<strong>vue</strong> <strong>React</strong>中<strong>数据流</strong>向是<strong>单向</strong>的，由父节点流向子节点，如果父节点的 props 发生了改变，那么 React 会递归遍历整个组件</p> <p><strong>父组件通过绑定 props 的方式，将数据传递给子组件，但是子组件自己并没有权利修改这些数据，如果要修改，只能把修改这一个行为通过 event 的方式报告给父组件，由父组件本身决定改如何处理数据。</strong></p> <p><strong>vue 另一个概念 v-model 双向数据 无论数据改变，或是用户操作，都能带来互相的变动，自动更新。</strong></p> <h2 id="如何在组件中监听-vuex-的数据变化"><a href="#如何在组件中监听-vuex-的数据变化" class="header-anchor">#</a> 如何在组件中监听 Vuex 的数据变化</h2> <blockquote><p>分析: 此题考查 Vuex 的应用及 Vue 内部的监听数据变化的机制</p></blockquote> <blockquote><p><strong><code>解答</code></strong>: 首先确定 Vuex 是为了解决什么问题而出现的 ? Vuex 是为了解决组件间状态共享而出现的一个框架.</p> <p>其中有几个要素 是组成 Vuex 的关键, state(状态) mutations actions ,</p> <p>state 表示 需要共享的状态数据</p> <p>mutations 表示 更改 state 的方法集合 只能是同步更新 不能写 ajax 等异步请求</p> <p>actions 如果需要做异步请求 可以在 actions 中发起 然后提交给 mutations mutation 再做同步更新</p></blockquote> <p>也就是 state 负责管理状态 , mutation 负责同步更新状态 action 负责 异步获取数据 同提交给 mutation</p> <blockquote><p>所以 组件监听 Vuex 数据变化 就是 监听 Vuex 中 state 的变化,</p></blockquote> <p><strong><code>第一种方案</code></strong> 我们可以在组件中通过组件的 <strong>watch 方法来做</strong>, 因为组件可以将 state 数据映射到 组件的计算属性上,</p> <p>然后 监听 映射的计算属性即可 代码如下</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// vuex中的state数据</span>
  <span class="token literal-property property">state</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

<span class="token comment">//  A组件中映射 state数据到计算属性</span>
  <span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'count'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token comment">// A组件监听 count计算属性的变化</span>
   <span class="token literal-property property">watch</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">count</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 用本身的数据进行一下计数</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>changeCount<span class="token operator">++</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div> <p><strong><code>第二种方案</code></strong> vuex 中 store 对象本身提供了**<code>watch</code>**函数 ,可以利用该函数进行监听</p> <ul><li><strong>watch(fn: Function, callback: Function, options?: Object): Function</strong></li></ul> <p>响应式地侦听 <code>fn</code> 的返回值，当值改变时调用回调函数。<code>fn</code> 接收 store 的 state 作为第一个参数，其 getter 作为第二个参数。最后接收一个可选的对象参数表示 Vue 的 <a href="https://cn.vuejs.org/v2/api/#vm-watch" target="_blank" rel="noopener noreferrer"><code>vm.$watch</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 方法的参数。</p> <p>代码</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>  <span class="token function">created</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">watch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> getters</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> state<span class="token punctuation">.</span>count
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>changeCount<span class="token operator">++</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><blockquote><p>以上代码 均在示例有体现</p></blockquote> <h2 id="vue-单页面和多页面的使用"><a href="#vue-单页面和多页面的使用" class="header-anchor">#</a> Vue 单页面和多页面的使用</h2> <p>morepage</p> <p>&lt;&gt;</p> <blockquote><p>分析: 首先分析,单页面应用和 多页面应用的根本区别</p> <p><strong><code>解答</code></strong>: 单页面即所有的模块统统置于一个 html 文件之上,切换模块,不会重新对 html 文件和资源进行再次请求,服务器不会对我们**<code>换页面</code>**的动作 产生任何反应, 所以我们感觉不到任何的刷新动作,速度和体验很畅快</p> <p>多页面应用 即多个 html 页面 共同的使用, 可以认为一个页面即一个模块,但是不排除 多个单页应用混合到一起的组合情况 , 多页面切换一定会造成 页面资源的重新加载, 这也就意味着 如果 多页面之间切换,一定会造成很数据的**<code>重置</code>**</p> <p>一个项目分成很多 小 vue 项目 你去其实也可以直接创建两个项目</p></blockquote> <p>1 **新建多个页面 每个页面是一个单独的小 vue 类型 **</p> <p>2 配置 多入口页面<strong>在 vue.config.js 里写上这些</strong> 重点是入口选择对应页面的 main.js</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//vue.config.js
module.exports = {
  pages: {
    index: {
      // page 的入口
      entry: &quot;src/views/index/main.js&quot;,
      // 模板来源
      template: &quot;public/index.html&quot;,
      // 在 dist/index.html 的输出
      filename: &quot;index.html&quot;,
      // 当使用 title 选项时，
      // template 中的 title 标签需要是 &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;
      title: &quot;Index Page&quot;
    },
    ui: {
      // page 的入口
      entry: &quot;src/views/ui/main.js&quot;,
      // 模板来源
      template: &quot;public/ui.html&quot;,
      // 在 dist/ui.html 的输出
      filename: &quot;ui.html&quot;,
      // 当使用 title 选项时，
      // template 中的 title 标签需要是 &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;
      title: &quot;ui Page&quot;
    }
  }
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>3 public 写上不同的渲染的 html</p> <p>4 main.js 不同的入口 对应上自己的 根组件和 页面元素</p> <p>5 通过 a 标签跳转</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;div id=&quot;app&quot;&gt;
    ui页面啊啊啊
    &lt;a href=&quot;home.html&quot;&gt;去home页面&lt;/a&gt;
  &lt;/div&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><img src="/img/aaa.png" alt="aaa"></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.2bec0f6e.js" defer></script><script src="/assets/js/2.0e47e04c.js" defer></script><script src="/assets/js/13.ffdc8d84.js" defer></script>
  </body>
</html>
